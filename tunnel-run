#!/usr/bin/env bash
set -euo pipefail

VERBOSE=false

# Detect if we're being run through a symlink
name=$(basename "$0")
truename=$(basename "$(realpath "$0")")

log() {
	if $VERBOSE; then
		echo "$@" >&2
	fi
}

die() {
	echo "$@" >&2; exit 1
}

ssh-run() {
	local rel mountspec server basepath
	rel=$(realpath . --relative-to="$(df . --output=target | sed -n 2p)")

	mountspec=$(df . --output=source | sed -n 2p)
	server=$(cut -d: -f1 <<< "$mountspec")
	basepath=$(cut -d: -f2- <<< "$mountspec")

	basepath=${basepath:-.} # Empty = relative to "current" dir
	basepath=${basepath%/} # Strip trailing slash
	basepath=${basepath:-/} # ...but restore it if the basepath is the root folder

	log "Running on $server relative to $basepath rel=$rel"

	exec ssh -tq -- "$server" "cd $(printf %q "$basepath/$rel") && exec $(printf "%q " "$@")"
}

local-run() {
	local cmd=$1
	shift

	realpath_self=$(realpath "$0")

	# We want to find the first command that *isn't* symlinked to us
	local candidate=""
	while read -r candidate; do
		[[ "$(realpath "$candidate")" != "$realpath_self" ]] && break
	done < <(which -a -- "$cmd" || die "$cmd not found")

	[[ -z "$candidate" ]] && die "$cmd not found"
	exec "$candidate" "$@"
}

dispatch() {
	local fs
	fs=$(df . --output=fstype | sed -n 2p)

	if [[ "${1:-}" = "locally" ]]; then
		fs=""
		shift
	fi

	if [[ "$#" = 0 ]]; then
		echo "Usage: $truename [locally] COMMAND [ARGS...]"
		exit
	fi

	case "$fs" in
		fuse.sshfs)
			ssh-run "$@"
			;;
		*)
			local-run "$@"
			;;
	esac
}

if [[ -L "$0" ]] && [[ "$name" != "$truename" ]]; then
	dispatch "$name" "$@"
else
	dispatch "$@"
fi
